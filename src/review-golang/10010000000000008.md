# golang中的协程是如何进行调度的？



Go语言中的goroutine调度是通过Go运行时（runtime）的调度器（scheduler）来实现的，这个调度器使用了一种叫做M:N调度的技术。这种调度机制允许多个（M）goroutines在较少的（N）操作系统线程上运行。这里的关键组件包括G、M和P：

- **G (Goroutine)**：代表一个goroutine，包含了执行所需的栈、指令和其他必要的状态。
- **M (Machine)**：代表一个操作系统线程，它在实际的处理器上执行代码。
- **P (Processor)**：代表逻辑处理器，它拥有一个本地的运行队列，可以分配G来执行。每个P必须绑定到一个M来执行其队列中的G。

### 调度过程
1. **创建Goroutine**：当使用`go`关键字创建goroutine时，它会被放入到一个本地或全局的运行队列中。
2. **P的分配**：每个P会从其本地队列中获取G来执行。如果本地队列为空，它可能会从全局队列或其他P的队列中“偷取”G。
3. **执行Goroutine**：一旦G被分配给P，P将把G绑定到一个M上执行。一个M在给定时间只能执行一个G，但可以在不同的G之间迅速切换。
4. **阻塞和唤醒**：如果G因为某些操作（如I/O操作或channel操作）而阻塞，它会被挂起，而M会继续执行其他的G。当阻塞操作完成后，G可以被放回队列，等待再次被调度。

### 调度策略
- **工作窃取**：为了保持所有的M忙碌，空闲的P会尝试从其他P的本地队列中“偷取”G来执行。
- **公平调度**：调度器尽量公平地分配CPU时间给所有的goroutine，以避免饿死（一些G得不到足够的CPU时间）的问题。
- **非抢占式调度**：在早期版本的Go中，一个G一旦开始执行，将持续执行直到它自行放弃控制权（如进行阻塞操作）。从Go 1.14开始，调度器引入了基于信号的抢占，这允许运行时系统在长时间运行的G中断其执行，将控制权让给其他G。

### 性能优化
由于其设计，Go的调度器能够在相对较少的操作系统线程上高效地管理大量goroutines的并发执行，这使得创建成千上万个goroutines变得可行而高效，极大地简化了并发编程和异步任务的处理。

总的来说，Go的调度器是为了提供高效、可扩展的并发性而设计的，通过智能的工作窃取和本地化队列管理，它能够在维持高性能的同时，简化并发和并行任务的编程复杂性。